#!/bin/sh
#
# Helper script to use the LTSmin tools and the Maude plugin
#

# Path to the LTSmin binaries
# (by default, we assume it is in the system path)
# LTSMIN_PATH=""
if [ -n "$LTSMIN_PATH" ]; then
	# We add a slash just in case it does not end in one
	LTSMIN_PATH="$LTSMIN_PATH/"
fi

# Full path of the Maude PINS plugin
# (by default, we look for it in the script directory)
# MAUDEMC_PATH=""
if [ -z "$MAUDEMC_PATH" ]; then
	if [ -z "$BASH_SOURCE" ]; then
		ourPath="$BASH_SOURCE"
	else
		ourPath="$(readlink -f $0)"
	fi

	MAUDEMC_PATH="$(dirname $ourPath)/libmaudemc.so"
fi

usage() {
	cat <<UsageTextLS
$0 MAUDE_FILE INITIAL_TERM [options]

Input data:
  --module NAME           Choose the module where to model check
  --strat EXPR            Select a strategy to control the system
  --aprops TEXT           Colon-separated list of atomic propositions

Maude options:
  --merge-states          Merge states
  --no-purge-fails        Do not purge fails
  --biased-matchrew       Enable the biased matchrew feature
  --opaque-strats         List of strategies to be considered opaque

Model checking options:
  --ltl FORMULA           Model check the formula against LTL
  --ctl FORMULA           Model check against CTL
  --ctl-star FORMULA      Model check against CTL*
  --mu FORMULA            Model check a mu calculus formula
  --mucalc FORMULA        Model check a mu calculus formula
  --invariant FORMULA     Check a predicate formula invariant

Where a formula is required a file can also be passed.
UsageTextLS
}

# Number of positional arguments provided
positionalArgs=0
# Flags for the merge-states and purge-fails features
mergeStates=0
purgeFails=1
# Additional arguments that this script does not handle explicitly
additionalArgs=""

# Process the command line arguments
while [ "$1" != "" ]; do
	case $1 in
		--help )	usage
				exit
				;;
		--module )	shift
				module=$1
				;;
		--strat )	shift
				strategy=$1
				;;
		--aprops )	shift
				aprops=$1
				;;
		--ltl \
		| --ctl \
		| --ctl-star \
		| --mu \
		| --mucalc \
		| --invariant )
				type="$(echo $1 | cut -c3-)"
				shift
				formula=$1
				;;
		--merge-states )
				mergeStates=1
				;;
		--no-purge-fails )
				purgeFails=0
				;;
		--biased-matchrew )
				additionalArgs="$additionalArgs	--biased-matchrew"
				;;
		--opaque-strats )
				additionalArgs="$additionalArgs	--opaque-strats	$2"
				shift
				;;
		--*)		echo "Unknown option $1."
				exit
				;;
		*)		case $positionalArgs in
					0)	file=$1	;;
					1)	initial=$1	;;
					*)	echo "Too many arguments $positionalArgs."
						exit
				esac
				positionalArgs=$((positionalArgs+1))
	esac
	shift

done

if [ "$positionalArgs" -lt "2" ]; then
	echo "Not enough arguments."
	usage
	exit
fi

# Selects the tool depending on what we want to do
case $type in
	ctl | ctl-star | mu | mucalc )	tool="sym" ;;
	* )				tool="seq"
esac

# Check the input data and construct the command arguments
tool_args="--loader=$MAUDEMC_PATH	$file	--initial=$initial"

if ! [ -r "$MAUDEMC_PATH" ]; then
	echo "Cannot access the Maude PINS plugin at $MAUDEMC_PATH."
	echo "Please, set the MAUDEMC_PATH variable to its location."
	exit
fi

if [ -n "$module" ]; then
	tool_args="$tool_args	--module=$module"
fi

# We require the atomic propositions colon-separated to allow
# easily splitting them without taking care about parentheses.
if [ -n "$aprops" ]; then
	cs_aprops="$(echo $aprops | tr ':' ',')"

	tool_args="$tool_args	--aprops=$cs_aprops"
fi

if [ -n "$strategy" ]; then
	tool_args="$tool_args	--strat=$strategy"

	# The ltsmin or textbook LTL semantics is required, since
	# otherwise LTSmin puts self-loops into deadlock states
	if [ "$type" == "ltl" ]; then
		tool_args="$tool_args	--ltl-semantics=ltsmin"
	else
		# Activate merge-states option if required
		if [ "$mergeStates" -eq "1" ]; then
			tool_args="$tool_args	--merge-states"
		fi
		# Activate purge-fails option if required
		if [ "$purgeFails" -eq "1" ]; then
			tool_args="$tool_args	--purge-fails"
		fi
	fi
else
	# However, for systems not controlled by strategies, the
	# completionn of deadlock states is desired and we
	# explictly select it.
	if [ "$type" == "ltl" ]; then
		tool_args="$tool_args	--ltl-semantics=spin"
	fi
fi

if [ -n "$type" ]; then
	if [ "$tool" == "sym" ] && [ -n "$aprops" ]; then
		props=$(echo $aprops | tr -d " " | tr ":" " " | tr -d "()" | tr "," "_")
		fake_inv="true"

		for pr in $props; do
			fake_inv="$fake_inv || $pr"
		done

		tool_args="$tool_args	--invariant=$fake_inv"
	fi

	tool_args="$tool_args	--$type=$formula"
fi

# The mucalc options requires calling a parity game solver to obtain its result
if [ "$type" == "mucalc" ]; then
	IFS="	"
	"${LTSMIN_PATH}pins2lts-$tool" $tool_args $additionalArgs --pg-write=game.spg
	exec "${LTSMIN_PATH}spgsolver" game.spg
else
	IFS="	"
	exec "${LTSMIN_PATH}pins2lts-$tool" $tool_args $additionalArgs
fi
